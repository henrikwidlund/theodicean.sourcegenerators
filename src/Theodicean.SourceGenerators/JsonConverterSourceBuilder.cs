using System.Text;

namespace Theodicean.SourceGenerators;

public static class JsonConverterSourceBuilder
{
    internal const string Attribute = $$"""
        #if THEODICEAN_GENERATORS_EMBED_ATTRIBUTES
    
        {{Constants.GeneratedCodeHeader}}
    
        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage(Justification = "Generated by the Theodicean.SourceGenerators.JsonConverter source generator.")]
        namespace Theodicean.SourceGenerators.JsonConverter;
    
        /// <summary>
        /// Add to enums to indicate that a JsonConverter for the enum should be generated.
        /// </summary>
        /// <typeparam name="TEnum">The enum to generate the converter for.</typeparam>
        [global::System.AttributeUsage(global::System.AttributeTargets.Class)]
        public class EnumJsonConverterAttribute<TEnum> : global::System.Attribute
            where TEnum : global::System.Enum
        {
            /// <summary>
            /// Indicates if the string representation is case-sensitive when deserializing it as an enum.
            /// </summary>
            public bool CaseSensitive { get; set; }
    
            /// <summary>
            /// Indicates if the value of <see cref=""PropertyName""/> should be camel cased.
            /// </summary>
            public bool CamelCase { get; set; }
    
            /// <summary>
            /// If set, this value will be used in messages when there are problems with validation and/or serialization/deserialization occurs.
            /// </summary>
            public string? PropertyName { get; set; }
        }
        #endif
        """;

    public static string GenerateJsonConverterClass(StringBuilder sb, JsonConverterToGenerate jsonConverterToGenerate)
    {
        sb.Append(Constants.GeneratedCodeHeader)
            .AppendLine();

        if (!string.IsNullOrEmpty(jsonConverterToGenerate.ConverterNamespace))
            sb.AppendLine().AppendLine($"namespace {jsonConverterToGenerate.ConverterNamespace};");

        sb.AppendLine()
            .AppendLine($$"""
            /// <summary>
            /// Converter to convert <see cref="global::{{jsonConverterToGenerate.FullyQualifiedEnumName}}" /> to and from strings.
            /// </summary>
            {{(jsonConverterToGenerate.IsPublic ? "public" : "internal")}} sealed partial class {{jsonConverterToGenerate.ConverterType}} : global::System.Text.Json.Serialization.JsonConverter<global::{{jsonConverterToGenerate.FullyQualifiedEnumName}}>
            {
            """);

        var propertyName = jsonConverterToGenerate.PropertyName;
        if (!string.IsNullOrEmpty(propertyName) && jsonConverterToGenerate.CamelCase)
            propertyName = propertyName.ToCamelCase();

        if (!string.IsNullOrEmpty(propertyName))
            sb.AppendLine($"""    private const string PropertyName = "{propertyName}";""")
                .AppendLine();
        
        sb.AppendLine($$"""
                /// <inheritdoc />
                /// <summary>
                /// Read and convert the JSON to <see cref="global::{{jsonConverterToGenerate.FullyQualifiedEnumName}}" />.
                /// </summary>
                /// <remarks>
                /// A converter may throw any Exception, but should throw <see cref="global::System.Text.Json.JsonException" /> when the JSON is invalid.
                /// </remarks>
                public override global::{{jsonConverterToGenerate.FullyQualifiedEnumName}} Read(ref global::System.Text.Json.Utf8JsonReader reader, global::System.Type typeToConvert, global::System.Text.Json.JsonSerializerOptions options)
                {
                    char[]? rentedBuffer = null;
                    var bufferLength = reader.HasValueSequence ? checked((int)reader.ValueSequence.Length) : reader.ValueSpan.Length;

                    var charBuffer = bufferLength <= 128
                        ? stackalloc char[128]
                        : rentedBuffer = global::System.Buffers.ArrayPool<char>.Shared.Rent(bufferLength);

                    var charsWritten = reader.CopyString(charBuffer);
                    charBuffer = charBuffer[..charsWritten];
                    global::System.ReadOnlySpan<char> source = charBuffer.Trim();

                    try
                    {
                        return GetEnumValue(source);
                    }
                    finally
                    {
                        if (rentedBuffer is not null)
                        {
                            charBuffer[..charsWritten].Clear();
                            global::System.Buffers.ArrayPool<char>.Shared.Return(rentedBuffer);
                        }
                    }
                }
            """)
            .AppendLine()
            .AppendLine($"""
                /// <inheritdoc />
                public override void Write(global::System.Text.Json.Utf8JsonWriter writer, global::{jsonConverterToGenerate.FullyQualifiedEnumName} value, global::System.Text.Json.JsonSerializerOptions options)
                    => writer.WriteStringValue(GetStringValue(value));
            """)
            .AppendLine();
            
        sb.Append(
                $"    private static global::{jsonConverterToGenerate.FullyQualifiedEnumName} GetEnumValue(in global::System.ReadOnlySpan<char> source)")
            .AppendLine()
            .AppendLine("    {");
        var stringComparison = jsonConverterToGenerate.CaseSensitive ? "global::System.StringComparison.Ordinal" : "global::System.StringComparison.OrdinalIgnoreCase";
        foreach ((string enumMember, EnumValueOption enumValueOption) in jsonConverterToGenerate.Members)
        {
            if (enumValueOption.DisplayName is not null)
            {
                if (enumMember.Equals(enumValueOption.DisplayName, StringComparison.OrdinalIgnoreCase))
                    sb.AppendLine($"""        if (source.Equals("{enumValueOption.DisplayName}".AsSpan(), {stringComparison}))""");
                else
                {
                    sb.AppendLine($"""        if (source.Equals("{enumValueOption.DisplayName}".AsSpan(), {stringComparison}) ||""")
                        .AppendLine($"""            source.Equals("{enumMember}".AsSpan(), {stringComparison}))""");
                }
                
                sb.AppendLine($"            return global::{jsonConverterToGenerate.FullyQualifiedEnumName}.{enumMember};")
                    .AppendLine();
            }
            else
            {
                sb.AppendLine($"""        if (source.Equals("{enumMember}".AsSpan(), {stringComparison}))""")
                    .AppendLine($"            return global::{jsonConverterToGenerate.FullyQualifiedEnumName}.{enumMember};")
                    .AppendLine();
            }
        }

        sb.AppendLine(
            !string.IsNullOrWhiteSpace(propertyName)
                ? """        throw new global::System.Text.Json.JsonException($"{source.ToString()} is not a valid value.", PropertyName, null, null);"""
                : """        throw new global::System.Text.Json.JsonException($"{source.ToString()} is not a valid value.", null, null, null);""");
        sb.AppendLine("    }")
            .AppendLine();
        
        sb.AppendLine(
                $"    private static string GetStringValue(in global::{jsonConverterToGenerate.FullyQualifiedEnumName} enumValue)")
            .AppendLine("        => enumValue switch")
            .AppendLine("        {");
        
        foreach ((string enumMember, EnumValueOption enumValueOption) in jsonConverterToGenerate.Members)
        {
            sb.AppendLine($"""            global::{jsonConverterToGenerate.FullyQualifiedEnumName}.{enumMember} => "{enumValueOption.DisplayName ?? enumMember}",""");
        }

        sb.AppendLine("            _ => throw new global::System.ArgumentOutOfRangeException(nameof(enumValue), enumValue, null)")
            .AppendLine("        };");
        
        sb.AppendLine("}");

        return sb.ToString();
    }
}
